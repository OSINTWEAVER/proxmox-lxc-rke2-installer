---
- name: Provision LXC containers on Proxmox hosts (Debian)
  hosts: proxmox_hosts
  become: true
  gather_facts: true
  vars:
    # Default map file; override with: -e lxc_map_file=playbooks/proxmox-vars/your_map.yml
    lxc_map_file: proxmox-vars/lxc_map_template.yml

  pre_tasks:
    - name: Load selected LXC map file
      ansible.builtin.include_vars:
        file: "{{ lxc_map_file }}"

    - name: Assert running on Debian (Proxmox)
      ansible.builtin.assert:
        that:
          - ansible_os_family == 'Debian'
        fail_msg: "This playbook must run against Proxmox (Debian) hosts as root."

    - name: Show LXC plan for this host
      ansible.builtin.debug:
        var: (proxmox_cluster.containers | selectattr('host', 'equalto', inventory_hostname) | list)

  tasks:
    - name: Ensure required kernel modules are loaded
      ansible.builtin.shell: |
        set -e
        modprobe overlay || true
        modprobe ip_tables || true
        modprobe ip6_tables || true
        modprobe nf_nat || true
        modprobe xt_conntrack || true
        modprobe br_netfilter || true
      args:
        executable: /bin/bash
      changed_when: false

    - name: Persist kernel modules across reboots
      ansible.builtin.lineinfile:
        path: /etc/modules
        line: "{{ item }}"
        create: true
      loop:
        - overlay
        - ip_tables
        - ip6_tables
        - nf_nat
        - xt_conntrack
        - br_netfilter

    - name: Configure sysctl for Kubernetes networking
      ansible.builtin.blockinfile:
        path: /etc/sysctl.conf
        marker: "# {mark} KUBERNETES_NETWORKING"
        block: |
          net.bridge.bridge-nf-call-iptables = 1
          net.bridge.bridge-nf-call-ip6tables = 1
          net.ipv4.ip_forward = 1
        create: true

    - name: Apply sysctl configuration
      ansible.builtin.shell: sysctl -p
      args:
        executable: /bin/bash
      changed_when: false

    - name: Prepare data storage for mounts (ZFS volumes and directories)
      ansible.builtin.include_tasks: utils/proxmox-mount-prep.yml
      when: item.host == inventory_hostname and (item.mounts is defined) and (mount is defined)
      loop: "{{ proxmox_cluster.containers | subelements('mounts', skip_missing=True) }}"
      loop_control:
        loop_var: item_mount
      vars:
        item: "{{ item_mount.0 }}"
        mount: "{{ item_mount.1 }}"

    - name: Build mount flags string for pct create
      when: item.host == inventory_hostname
      ansible.builtin.set_fact:
        pct_mount_flags: >-
          {%- set flags = [] -%}
          {%- if item.mounts is defined -%}
          {%- for m in item.mounts -%}
            {%- set idx = loop.index0 -%}
            {%- if m.type == 'zfs_volume' -%}
              {%- set src = '/dev/zvol/' + (m.pool | default(proxmox_cluster.storage_defaults.zfs_pool)) + '/' + m.name -%}
            {%- elif m.type == 'directory' -%}
              {%- set src = m.host_path -%}
            {%- elif m.type == 'storage' -%}
              {#- For storage-backed mountpoints, pct expects key/value params (mp=,storage=,size=) -#}
              {%- set src = None -%}
            {%- elif m.type == 'lvm_lv' -%}
              {%- set src = '/dev/' + m.vg + '/' + m.lv -%}
            {%- else -%}
              {%- set src = '' -%}
            {%- endif -%}
            {%- if m.type == 'storage' -%}
              {# Build: --mp{n} <storage>:<SIZE_GiB>,mp=/path[,<options>]
                 Use the documented STORAGE_ID:SIZE_IN_GiB placeholder so pct auto-allocates volumes (fixes local-lvm LV missing errors).
              #}
              {%- set storage = m.storage | default(proxmox_cluster.storage_defaults.rootfs.split(':')[0]) -%}
              {# Parse size into GiB integer #}
              {%- set rawsz = (m.size | string) -%}
              {%- set lower = rawsz | lower -%}
              {%- if lower.endswith('t') -%}
                {%- set size_gib = (((lower[0:-1] | float) * 1024) | round(0, 'floor')) | int -%}
              {%- elif lower.endswith('g') -%}
                {%- set size_gib = ((lower[0:-1] | float) | round(0, 'floor')) | int -%}
              {%- elif lower.endswith('m') -%}
                {%- set size_gib = ((((lower[0:-1] | float) / 1024) | round(0, 'ceil')) | int) | max(1) -%}
              {%- else -%}
                {%- set size_gib = (lower | float) | round(0, 'floor') | int -%}
              {%- endif -%}
              {%- set base = '--mp' ~ idx ~ ' ' ~ storage ~ ':' ~ (size_gib | string) ~ ',mp=' ~ m.container_path -%}
              {%- if m.options is defined and m.options|length > 0 -%}
                {%- set _ = flags.append(base ~ (m.options if m.options.startswith(',') else (',' ~ m.options))) -%}
              {%- elif m.read_only | default(false) -%}
                {%- set _ = flags.append(base ~ ',ro=1') -%}
              {%- else -%}
                {%- set _ = flags.append(base) -%}
              {%- endif -%}
            {%- elif src -%}
              {# Build: --mp{n} <src>,mp=/path[,<options>] #}
              {%- set base = '--mp' + idx|string + ' ' + src + ',mp=' + m.container_path -%}
              {%- if m.options is defined and m.options|length > 0 -%}
                {%- set _ = flags.append(base + (m.options if m.options.startswith(',') else (',' + m.options))) -%}
              {%- elif m.read_only | default(false) -%}
                {%- set _ = flags.append(base + ',ro=1') -%}
              {%- else -%}
                {%- set _ = flags.append(base) -%}
              {%- endif -%}
            {%- endif -%}
          {%- endfor -%}
          {%- endif -%}
          {{ flags | join(' ') }}
      loop: "{{ proxmox_cluster.containers }}"
      register: pct_mount_flags_results

    - name: Map results to host/container id
      when: item.item.host == inventory_hostname
      ansible.builtin.set_fact:
        pct_mount_flags_map: "{{ (pct_mount_flags_map | default({})) | combine({ item.item.id: (item.ansible_facts.pct_mount_flags | trim) }) }}"
      loop: "{{ pct_mount_flags_results.results }}"

    - name: Create LXC containers if missing
      when: item.host == inventory_hostname
      ansible.builtin.shell: >-
        pct create {{ item.id }} {{ proxmox_cluster.template }}
        --hostname {{ item.hostname }}
        --memory {{ item.memory }}
        --cores {{ item.cores }}
        --net0 name=eth0,bridge={{ proxmox_cluster.bridge }},firewall=1,gw={{ proxmox_cluster.gateway }},ip={{ item.ip }}{% if proxmox_cluster.vlan_tag is defined and proxmox_cluster.vlan_tag and proxmox_cluster.vlan_tag != 0 %},tag={{ proxmox_cluster.vlan_tag }}{% endif %},type=veth{% if proxmox_cluster.mtu is defined and proxmox_cluster.mtu %},mtu={{ proxmox_cluster.mtu }}{% endif %}
        --ostype ubuntu --swap 0 --rootfs {{ item.rootfs }}
        {{ pct_mount_flags_map[item.id] | default('') }}
        --unprivileged 0
      args:
        executable: /bin/bash
        creates: "/etc/pve/nodes/{{ ansible_hostname }}/lxc/{{ item.id }}.conf"
      loop: "{{ proxmox_cluster.containers }}"

    - name: Apply LXC security profile for Kubernetes (idempotent)
      when: item.host == inventory_hostname
      ansible.builtin.blockinfile:
        path: "/etc/pve/nodes/{{ ansible_hostname }}/lxc/{{ item.id }}.conf"
        marker: "# {mark} LXC_K8S_SETTINGS"
        block: |
          lxc.apparmor.profile = unconfined
          lxc.cgroup2.devices.allow: a
          lxc.cgroup2.devices.allow: b
          lxc.cgroup2.devices.allow: c 195:* rwm
          lxc.cgroup2.devices.allow: c 510:* rwm
          lxc.cgroup2.devices.allow: c 235:* rwm
          lxc.cgroup2.devices.allow: c 0:* rwm
          lxc.mount.auto: proc:rw sys:rw cgroup:rw
          lxc.mount.entry: /dev/dri dev/dri none bind,optional,create=dir
          lxc.mount.entry: /dev/nvidia0 dev/nvidia0 none bind,optional,create=file
          lxc.mount.entry: /dev/nvidia1 dev/nvidia1 none bind,optional,create=file
          lxc.mount.entry: /dev/nvidia-uvm dev/nvidia-uvm none bind,optional,create=file
          lxc.mount.entry: /dev/nvidia-uvm-tools dev/nvidia-uvm-tools none bind,optional,create=file
          lxc.mount.entry: /dev/nvidia-modeset dev/nvidia-modeset none bind,optional,create=file
          lxc.mount.entry: /dev/nvidiactl dev/nvidiactl none bind,optional,create=file
          lxc.mount.entry: /dev/nvidia-caps dev/nvidia-caps none bind,optional,create=dir
          lxc.prlimit.memlock: unlimited
      loop: "{{ proxmox_cluster.containers }}"

    - name: Start LXC containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: pct start {{ item.id }}
      args:
        executable: /bin/bash
      register: start_container_result
      changed_when: start_container_result.rc == 0
      failed_when: start_container_result.rc not in [0, 133]  # 133 = already running
      loop: "{{ proxmox_cluster.containers }}"

    - name: Wait for containers to be fully started
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        for i in {1..30}; do
          if pct exec {{ item.id }} -- test -f /proc/version; then
            echo "Container {{ item.id }} is ready"
            exit 0
          fi
          echo "Waiting for container {{ item.id }} to be ready... ($i/30)"
          sleep 3
        done
        echo "Container {{ item.id }} failed to start properly"
        exit 1
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    # ===== POST-CREATION CONTAINER CONFIGURATION =====
    
    - name: Disable swap in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        # Disable swap completely
        pct exec {{ item.id }} -- swapoff -a
        # Remove swap from fstab
        pct exec {{ item.id }} -- sed -i '/swap/d' /etc/fstab
        # Remove common swap files and devices
        pct exec {{ item.id }} -- sh -c 'if [ -e /swapfile ]; then swapoff /swapfile 2>/dev/null || true; rm -f /swapfile; fi'
        # Disable systemd swap services
        pct exec {{ item.id }} -- systemctl mask swap.target 2>/dev/null || true
        pct exec {{ item.id }} -- systemctl stop swap.target 2>/dev/null || true
        echo "Swap disabled for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Update apt cache in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- apt update
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install required pre-install packages in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        set -e
        # ensure package list is fresh
        pct exec {{ item.id }} -- apt update
        pct exec {{ item.id }} -- apt install -y wireguard iptables socat unzip jq \
          python3 python3-venv python3-pip \
          build-essential curl ca-certificates gnupg \
          openssl openjdk-21-jdk git sshpass p7zip-full \
          vim lsb-release sudo software-properties-common rsync
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install Ansible from PPA in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        set -e
        pct exec {{ item.id }} -- apt install -y software-properties-common
        pct exec {{ item.id }} -- add-apt-repository --yes --update ppa:ansible/ansible
        pct exec {{ item.id }} -- apt install -y ansible-core ansible-lint python3-paramiko python3-jmespath python3-netaddr sshpass
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install Ansible community collections in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        set -e
        pct exec {{ item.id }} -- ansible-galaxy collection install community.general ansible.posix kubernetes.core community.crypto --force
      args:
        executable: /bin/bash
      register: ansible_collection_install
      failed_when: false  # Don't fail if already installed
      loop: "{{ proxmox_cluster.containers }}"

    # ===== SYSTEM CONFIGURATION AND LOCALIZATION =====

    - name: Configure UTF-8 locale and timezone in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        set -e
        # Generate and set UTF-8 locale
        pct exec {{ item.id }} -- locale-gen en_US.UTF-8
        pct exec {{ item.id }} -- update-locale LANG=en_US.UTF-8 LC_ALL=en_US.UTF-8
        # Set timezone to UTC
        pct exec {{ item.id }} -- timedatectl set-timezone UTC
        echo "Locale and timezone configured for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Disable Ubuntu telemetry and bloatware in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        set -e
        # Disable Ubuntu Pro ads and telemetry
        pct exec {{ item.id }} -- systemctl disable ubuntu-advantage || true
        pct exec {{ item.id }} -- systemctl stop ubuntu-advantage || true
        pct exec {{ item.id }} -- apt remove -y ubuntu-advantage-tools || true
        # Disable crash reporting
        pct exec {{ item.id }} -- systemctl disable apport || true
        pct exec {{ item.id }} -- systemctl stop apport || true
        # Disable popularity contest
        pct exec {{ item.id }} -- apt remove -y popularity-contest || true
        # Disable motd ads
        pct exec {{ item.id }} -- chmod -x /etc/update-motd.d/10-help-text || true
        pct exec {{ item.id }} -- chmod -x /etc/update-motd.d/80-esm || true
        pct exec {{ item.id }} -- chmod -x /etc/update-motd.d/95-hwe-eol || true
        echo "Telemetry and bloatware disabled for container {{ item.id }}"
      args:
        executable: /bin/bash
      register: disable_telemetry_result
      failed_when: false  # Don't fail if packages don't exist
      loop: "{{ proxmox_cluster.containers }}"

    - name: Configure automatic security updates in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        set -e
        # Install unattended-upgrades
        pct exec {{ item.id }} -- apt install -y unattended-upgrades apt-listchanges
        # Configure automatic security updates
        pct exec {{ item.id }} -- bash -c 'echo "APT::Periodic::Update-Package-Lists \"1\";" > /etc/apt/apt.conf.d/20auto-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "APT::Periodic::Download-Upgradeable-Packages \"1\";" >> /etc/apt/apt.conf.d/20auto-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "APT::Periodic::AutocleanInterval \"7\";" >> /etc/apt/apt.conf.d/20auto-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "APT::Periodic::Unattended-Upgrade \"1\";" >> /etc/apt/apt.conf.d/20auto-upgrades'
        # Configure to only install security updates automatically
        pct exec {{ item.id }} -- bash -c 'echo "Unattended-Upgrade::Allowed-Origins {" > /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "    \"\${distro_id}:\${distro_codename}-security\";" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "    \"\${distro_id} ESMApps:\${distro_codename}-apps-security\";" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "    \"\${distro_id} ESM:\${distro_codename}-infra-security\";" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "};" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "Unattended-Upgrade::AutoFixInterruptedDpkg \"true\";" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "Unattended-Upgrade::MinimalSteps \"true\";" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "Unattended-Upgrade::Remove-Unused-Dependencies \"true\";" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        pct exec {{ item.id }} -- bash -c 'echo "Unattended-Upgrade::Automatic-Reboot \"false\";" >> /etc/apt/apt.conf.d/50unattended-upgrades'
        echo "Automatic security updates configured for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Perform initial system update and upgrade in containers
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        set -e
        # Update package lists and upgrade all packages
        pct exec {{ item.id }} -- apt update
        pct exec {{ item.id }} -- apt upgrade -y
        # Clean up package cache
        pct exec {{ item.id }} -- apt autoremove -y
        pct exec {{ item.id }} -- apt autoclean
        echo "System updated and cleaned for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    # ===== HIGH-SPEED NETWORKING CONFIGURATION =====
    
    - name: Configure hostname advertising and network discovery
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        # Configure hostname advertising for network discovery
        pct exec {{ item.id }} -- bash -c 'echo "{{ item.hostname }}" > /etc/hostname'
        pct exec {{ item.id }} -- bash -c 'hostnamectl set-hostname {{ item.hostname }}'
        # Enable multicast support
        pct exec {{ item.id }} -- bash -c 'echo "net.ipv4.conf.all.mc_forwarding = 1" >> /etc/sysctl.conf'
        pct exec {{ item.id }} -- bash -c 'echo "net.ipv4.conf.default.mc_forwarding = 1" >> /etc/sysctl.conf'
        echo "Hostname and multicast configured for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Disable UFW and configure network settings
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        # Disable UFW firewall
        pct exec {{ item.id }} -- ufw --force disable || true
        pct exec {{ item.id }} -- systemctl disable ufw || true
        pct exec {{ item.id }} -- systemctl stop ufw || true
        echo "UFW disabled for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Configure high-speed networking and disable IPv6
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        # Add networking optimizations for 50Gbit
        pct exec {{ item.id }} -- bash -c "cat >> /etc/sysctl.conf << 'EOFSYSCTL'
        # High-speed networking optimizations for 50Gbit
        net.ipv4.ip_forward = 1
        net.core.rmem_default = 262144
        net.core.rmem_max = 134217728
        net.core.wmem_default = 262144
        net.core.wmem_max = 134217728
        net.core.netdev_max_backlog = 30000
        net.ipv4.tcp_rmem = 4096 87380 134217728
        net.ipv4.tcp_wmem = 4096 65536 134217728
        net.ipv4.tcp_congestion_control = bbr
        net.core.default_qdisc = fq
        net.ipv4.tcp_mtu_probing = 1
        
        # Disable IPv6
        net.ipv6.conf.all.disable_ipv6 = 1
        net.ipv6.conf.default.disable_ipv6 = 1
        net.ipv6.conf.lo.disable_ipv6 = 1
        EOFSYSCTL"
        # Apply sysctl settings
        pct exec {{ item.id }} -- sysctl -p
        echo "Network optimizations applied for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install NFS and SMB3 support
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- apt-get update
        pct exec {{ item.id }} -- apt-get install -y nfs-common cifs-utils smbclient
        echo "NFS and SMB3 support installed for container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Start containers if not running
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        pct status {{ item.id }} | grep -q running || pct start {{ item.id }}
      args:
        executable: /bin/bash
      changed_when: false
      loop: "{{ proxmox_cluster.containers }}"

    - name: Ensure administrative SSH user exists inside containers
      when: item.host == inventory_hostname
      vars:
        user_name: "{{ item.ssh_user | default(proxmox_cluster.ssh.username | default('adm4n')) }}"
        user_password: "{{ item.ssh_password | default(proxmox_cluster.ssh.password | default('CHANGE_THIS_PASSWORD')) }}"
      ansible.builtin.shell: |
        set -e
        pct exec {{ item.id }} -- bash -lc 'id -u {{ user_name }} >/dev/null 2>&1 || adduser --disabled-password --gecos "" {{ user_name }}'
        pct exec {{ item.id }} -- bash -lc 'echo "{{ user_name }}:{{ user_password }}" | chpasswd'
        pct exec {{ item.id }} -- bash -lc 'usermod -aG sudo {{ user_name }}'
        pct exec {{ item.id }} -- bash -lc 'echo "{{ user_name }} ALL=(ALL) NOPASSWD:ALL" | EDITOR="tee" visudo -f /etc/sudoers.d/{{ user_name }}'
        pct exec {{ item.id }} -- bash -lc 'mkdir -p /home/{{ user_name }}/.ssh && chmod 700 /home/{{ user_name }}/.ssh && chown -R {{ user_name }}:{{ user_name }} /home/{{ user_name }}'
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Download NVIDIA driver into GPU containers (if defined)
      when: item.host == inventory_hostname and (item.gpu | default(false))
      vars:
        driver_version: "{{ nvidia_driver_version | default('580.82.07') }}"
        driver_url: "https://us.download.nvidia.com/XFree86/Linux-x86_64/{{ driver_version }}/NVIDIA-Linux-x86_64-{{ driver_version }}.run"
        driver_filename: "NVIDIA-Linux-x86_64-{{ driver_version }}.run"
        dest_dir: "{{ item.nvidia_driver_dest_path | default('/root') }}"
      ansible.builtin.shell: |
        echo "Downloading NVIDIA driver {{ driver_version }} for container {{ item.id }}"
        pct exec {{ item.id }} -- wget -O "{{ dest_dir }}/{{ driver_filename }}" "{{ driver_url }}"
        pct exec {{ item.id }} -- chmod +x "{{ dest_dir }}/{{ driver_filename }}"
        echo "Downloaded and made executable: {{ dest_dir }}/{{ driver_filename }} in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install NVIDIA driver dependencies in GPU containers
      when: item.host == inventory_hostname and (item.gpu | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- apt update
        pct exec {{ item.id }} -- apt install -y build-essential dkms linux-headers-generic wget
        echo "NVIDIA driver dependencies installed in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install NVIDIA driver in GPU containers
      when: item.host == inventory_hostname and (item.gpu | default(false))
      vars:
        driver_version: "{{ nvidia_driver_version | default('580.82.07') }}"
        driver_filename: "NVIDIA-Linux-x86_64-{{ driver_version }}.run"
        dest_dir: "{{ item.nvidia_driver_dest_path | default('/root') }}"
      ansible.builtin.shell: |
        # Remove existing NVIDIA packages
        pct exec {{ item.id }} -- apt-get remove --purge '^nvidia-.*' libnvidia-* || true
        pct exec {{ item.id }} -- apt-get autoremove --purge -y || true
        
        # Install NVIDIA driver
        driver_file="{{ dest_dir }}/{{ driver_filename }}"
        if pct exec {{ item.id }} -- test -f "$driver_file"; then
          echo "Installing NVIDIA driver {{ driver_version }} in container {{ item.id }}"
          pct exec {{ item.id }} -- bash -c "cd {{ dest_dir }} && ./{{ driver_filename }} --dkms --no-questions --ui=none --disable-nouveau"
          echo "NVIDIA driver installation completed for container {{ item.id }}"
        else
          echo "ERROR: NVIDIA driver file not found: $driver_file in container {{ item.id }}"
          exit 1
        fi
      args:
        executable: /bin/bash
      register: nvidia_driver_install
      failed_when: false
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install NVIDIA driver dependencies in GPU containers
      when: item.host == inventory_hostname and (item.gpu | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- apt update
        pct exec {{ item.id }} -- apt install -y build-essential dkms linux-headers-generic
        echo "NVIDIA driver dependencies installed in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install NVIDIA driver in GPU containers
      when: item.host == inventory_hostname and (item.gpu | default(false))
      vars:
        driver_version: "{{ item.nvidia_driver_version | default(proxmox_cluster.nvidia.driver_version | default('575.64.05')) }}"
        dest_dir: "{{ item.nvidia_driver_dest_path | default(proxmox_cluster.nvidia.driver_dest_path | default('/root')) }}"
      ansible.builtin.shell: |
        driver_file="{{ dest_dir }}/NVIDIA-Linux-x86_64-{{ driver_version }}.run"
        if pct exec {{ item.id }} -- test -f "$driver_file"; then
          echo "Installing NVIDIA driver in container {{ item.id }}"
          pct exec {{ item.id }} -- chmod +x "$driver_file"
          pct exec {{ item.id }} -- bash -c "$driver_file --dkms --no-questions --ui=none --no-kernel-module --no-drm --install-libglvnd"
          pct exec {{ item.id }} -- ldconfig
          echo "NVIDIA driver installed in container {{ item.id }}"
        else
          echo "NVIDIA driver installer not found in container {{ item.id }} at $driver_file"
          exit 1
        fi
      args:
        executable: /bin/bash
      register: nvidia_driver_install
      failed_when: false
      loop: "{{ proxmox_cluster.containers }}"

    - name: Test NVIDIA driver installation in GPU containers
      when: item.host == inventory_hostname and (item.gpu | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- nvidia-smi
      args:
        executable: /bin/bash
      register: nvidia_test
      failed_when: false
      loop: "{{ proxmox_cluster.containers }}"

    - name: Display NVIDIA driver test results
      when: item.item.host == inventory_hostname and (item.item.gpu | default(false))
      debug:
        msg: "Container {{ item.item.id }} NVIDIA test: {{ 'PASSED' if item.rc == 0 else 'FAILED' }}"
      loop: "{{ nvidia_test.results | default([]) }}"

    - name: Install Docker dependencies in containers that need Docker
      when: item.host == inventory_hostname and (item.docker | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- apt update
        pct exec {{ item.id }} -- apt install -y ca-certificates curl gnupg lsb-release
        echo "Docker dependencies installed in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Add Docker GPG key in containers that need Docker
      when: item.host == inventory_hostname and (item.docker | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- bash -c 'curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg'
        echo "Docker GPG key added in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Add Docker repository in containers that need Docker
      when: item.host == inventory_hostname and (item.docker | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- bash -c 'echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" > /etc/apt/sources.list.d/docker.list'
        pct exec {{ item.id }} -- apt update
        echo "Docker repository added in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Install Docker CE in containers that need Docker
      when: item.host == inventory_hostname and (item.docker | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- apt install -y docker-ce docker-ce-cli docker-compose-plugin
        echo "Docker CE installed in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Create optimal Docker daemon configuration for LXC with AppArmor support
      when: item.host == inventory_hostname and (item.docker | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- bash -c 'cat > /etc/docker/daemon.json << "EOF"
        {
          "storage-driver": "vfs",
          "log-driver": "json-file",
          "log-opts": {
            "max-size": "10m",
            "max-file": "3"
          },
          "exec-opts": ["native.cgroupdriver=systemd"],
          "live-restore": false,
          "userland-proxy": false,
          "iptables": false,
          "bridge": "none",
          "apparmor-profile": "",
          "security-opts": ["apparmor:unconfined"]
        }
        EOF'
        echo "Docker daemon configuration with AppArmor support created in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Start and enable Docker service in containers that need Docker
      when: item.host == inventory_hostname and (item.docker | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- systemctl enable docker
        pct exec {{ item.id }} -- systemctl start docker
        echo "Docker service started in container {{ item.id }}"
      args:
        executable: /bin/bash
      register: docker_start_result
      failed_when: false
      loop: "{{ proxmox_cluster.containers }}"

    - name: Add user to docker group in containers that have Docker
      when: item.host == inventory_hostname and (item.docker | default(false))
      vars:
        user_name: "{{ item.ssh_user | default(proxmox_cluster.ssh.username | default('adm4n')) }}"
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- usermod -aG docker {{ user_name }}
        echo "User {{ user_name }} added to docker group in container {{ item.id }}"
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"

    - name: Test Docker installation in containers that need Docker
      when: item.host == inventory_hostname and (item.docker | default(false))
      ansible.builtin.shell: |
        pct exec {{ item.id }} -- docker --version
        pct exec {{ item.id }} -- docker info >/dev/null 2>&1 && echo "Docker is working" || echo "Docker test failed"
      args:
        executable: /bin/bash
      register: docker_test
      failed_when: false
      loop: "{{ proxmox_cluster.containers }}"

    - name: Display Docker test results
      when: item.item.host == inventory_hostname and (item.item.docker | default(false))
      debug:
        msg: "Container {{ item.item.id }} Docker test: {{ 'PASSED' if 'Docker is working' in item.stdout else 'FAILED' }}"
      loop: "{{ docker_test.results | default([]) }}"

    - name: Show container status
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        pct status {{ item.id }}
      args:
        executable: /bin/bash
      register: pct_status_out
      changed_when: false
      loop: "{{ proxmox_cluster.containers }}"

    - name: Print status summaries
      ansible.builtin.debug:
        msg: "ID {{ item.item.id }} -> {{ item.stdout | default('') }}"
      loop: "{{ pct_status_out.results | default([]) }}"

    - name: Reboot containers (pct reboot) at end of provisioning
      when: item.host == inventory_hostname
      ansible.builtin.shell: |
        echo "Rebooting container {{ item.id }}"
        pct reboot {{ item.id }} || (sleep 2 && pct start {{ item.id }} )
      args:
        executable: /bin/bash
      loop: "{{ proxmox_cluster.containers }}"
